[{"content":"Mysql 结构图： Server 层包括连接器、查询缓存、分析器、优化器、执行器等\n存储引擎层负责数据的存储和提取。InnoDB、MyISAM 引擎\n使用docker 创建实验环境： 1 2 3 4 5 6  sodu docker run -p 3306:3306 --name mysql \\ -v /usr/local/docker/mysql/conf:/etc/mysql \\ -v /usr/local/docker/mysql/logs:/var/log/mysql \\ -v /usr/local/docker/mysql/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ -d mysql:5.7   连接器 TCP 请求验证身份\nshow processlist；可以查看连接状态\n过多的长链接会占用大量内容存\n 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。  查询缓存 MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。\n查询缓存在实际情况下失效非常频繁，只要对一个表更新，表上的查询缓存都会被清空，对于更新压力大的数据库，查询缓存的命中率会非常低。\n分析器 词法分析\n检查语法错误\n查看 最后的 use near 的提醒\n优化器 优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。\n执行器 判断权限\n执行查询语句\nrows_examined 累加扫描多少行数据\n更新流程 redo log WAL:Write-Ahead Logging 先写日志，在写磁盘\ninnodb会在空闲时候保存到磁盘\n如果redo log 写满了会阻塞，将记录更新，腾出空间\nInnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。\n1  showvariableslike\u0026#39;%innodb_log_file%\u0026#39;;  有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。\nbinlog MyISAM 是MySQL 自带的。innodb是另一个公司以插件形式引入MySQL的。\nMyISAM 没有crash-safe能力。\n数据库恢复：\n找到最近的一次全量备份，从备份时间开始 将备份的binlog依次取出来\n两阶段提交：\n必须先写redolog,因为如果蹦了，binlog如果先写\n","date":"2022-06-17T13:32:01+08:00","image":"https://example.com/p/mysql%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/1516163958219817909_huc41da6b3f69990a6b8ff48e2f4b65e49_28294_120x120_fill_q75_box_smart1.jpeg","permalink":"https://example.com/p/mysql%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/","title":"mysql知识体系"},{"content":"Git常用命令整理.\n 本文只包含对常用git命令的整理，后续会不定时更新\u0026hellip;\u0026hellip;\n ssh-keygen 1  ssh-keygen -t rsa -C \u0026#34;your email adress\u0026#34;   git config 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  # 配置用户名 git config --global user.name \u0026#34;your name\u0026#34; # 配置用户邮箱 git config --global user.email \u0026#34;your email\u0026#34; # 配置pull合并方式 git config --global pull.rebase false # 查看全局配置 git config --global --list # socks代理 git config --global http.proxy \u0026#39;socks5://127.0.0.1:7890\u0026#39; git config --global https.proxy \u0026#39;socks5://127.0.0.1:7890\u0026#39; # http代理 git config --global https.proxy \u0026#39;http://127.0.0.1:7890\u0026#39; git config --global https.proxy \u0026#39;https://127.0.0.1:7890\u0026#39; # 取消配置(例如取消代理配置) git config --global --unset http.proxy git config --global --unset https.proxy   git clone 1 2 3  git clone \u0026lt;repository\u0026gt; # 递归拉取(一般用在仓库中有子模块的时候) git clone --recursive \u0026lt;repository\u0026gt;   git branch 1 2 3 4 5 6 7 8 9 10 11 12  # 查看本地分支列表 git branch -l # 查看远程分支列表 git branch -r # 查看本地+远程分支列表 git branch -a # 新建一个分支，但依然停留在当前分支 git branch \u0026lt;branchname\u0026gt; # 现有分支与指定的远程分支建立追踪关系 git branch -u \u0026lt;remote-branchname\u0026gt; # 删除本地分支 git branch -d \u0026lt;branchname\u0026gt;   git add 1 2 3 4 5  # 添加所有变化 git add . git add -A # 添加被修改，被删除的变化，不包括新增的文件 git add -u   git checkout 1 2 3 4 5 6 7 8  # 切换到指定分支 git checkout \u0026lt;branch\u0026gt; # 基于现有分支创建新分支，并切换至新分支 git checkout -b \u0026lt;branch\u0026gt; # 基于远程分支创建新分支，并切换至新分支 git checkout -b \u0026lt;branch\u0026gt; \u0026lt;remote-branch\u0026gt; # 恢复暂存区指定文件到工作区 git checkout \u0026lt;file\u0026gt;   git restore 1 2 3 4  # 丢弃工作区指定文件的变化 git restore \u0026lt;file\u0026gt; # 丢弃工作区所有变化 git restore .   git commit 1 2 3 4 5 6  # 提交暂存区文件到仓库 git commit -m \u0026lt;message\u0026gt; # 提交至上个commit git commit --amend # 提交至上个commit(包括工作区的内容) git commit --amend -a   git tag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # 列出所有tag git tag -l # 查看tag信息 git show \u0026lt;tagname\u0026gt; # 在当前commit新建一个tag git tag \u0026lt;tagname\u0026gt; # 在指定commit新建一个tag git tag \u0026lt;tagname\u0026gt; \u0026lt;commit\u0026gt; # 推送指定tag至远程仓库 git push origin \u0026lt;tagname\u0026gt; # 推送所有tag至远程仓库 git push origin --tags # 删除本地tag git tag -d \u0026lt;tagname\u0026gt; # 删除远程tag git push origin :refs/tags/\u0026lt;tagname\u0026gt;   git status 1 2  # 显示所有变更的文件 git status   git log 1 2 3 4 5 6 7 8 9 10 11 12  # 显示所有提交过的版本信息 git log --graph # 显示过去n次提交过的版本信息 git log -n # 根据关键词搜索提交历史 git log -S \u0026lt;keyword\u0026gt; # 显示某个文件的版本历史，包括文件改动 git log --follow \u0026lt;file\u0026gt; # 显示暂存区和工作区的差异 git diff # 显示两次提交之间的差异 git diff \u0026lt;commit1\u0026gt; \u0026lt;commit2\u0026gt;   git reflog 1 2 3  # 显示所有分支的操作记录，包括已经被删除的 commit 记录和 reset 的操作 git reflog git reflog -n   git reset 1 2  # 回退至指定commit git reset --hard \u0026lt;commit\u0026gt;   git push 1 2 3 4 5 6 7 8  # 推送本地分支至对应的远程分支 git push # 推送本地分支至指定的远程分支，并建立追踪 git push -u origin \u0026lt;branch\u0026gt; # 强制推送 git push --force # 删除远程分支 git push origin --delete \u0026lt;branchname\u0026gt;   git pull 1 2  # 拉取远程仓库的变化，并与本地分支合并 git pull   git fetch 1 2 3 4 5 6  # 取回远程主机特定分支的更新 到 本地对应的远程分支 git fetch \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; # 创建并更新远程分支到本地远程分支。 git fetch # 手动指定了要fetch的remote。在不指定分支时通常默认为master git fetch \u0026lt;remote\u0026gt;     pull:拉取远程仓库的变化到本地远程分支，并与本地分支合并 fetch:拉取远程仓库的变化到本地远程分支，但不与本地分支合并   git remote 1 2 3 4  # 显示所有远程仓库 git remote -v # 把本地仓库和远程仓库关联 git remote add origin \u0026lt;repository\u0026gt;   git submodule 1 2 3 4 5 6 7 8  # 添加子模块 git submodule add \u0026lt;repository\u0026gt; \u0026lt;path\u0026gt; # 初始化子模块 git submodule init # 更新子模块 git submodule update # 拉取所有子模块 git submodule foreach git pull   git rebase 1 2  # 合并当前commit到指定commit的记录 git rebase -i \u0026lt;commit\u0026gt;   以下是2种合并方式的比较:\n merge:使用简单，但每次合并时会生成一个新的合并点；merge操作遇到冲突的时候，当前merge不能继续进行下去。手动修改冲突内容后，add修改，commit就可以继续往下操作。 rebase:操作稍微复杂，会把你当前分支的 commit放到公共分支的最前面(靠近HEAD)；rebase操作遇到冲突的时候会中断rebase，同时会提示去解决冲突。解决冲突后，将修改add后执行git rebase —-continue继续操作，或者git rebase —-skip忽略冲突。  一般推荐使用rebase，因为merge之后会有记录，然后在提交PR(Pull/Request)会很难看。\n 给fork配置一个remote  使用git remote -v查看远程状态 添加一个将被同步给fork远程的上游仓库(源名称一般建议upstream，可修改) 1  git remote add upstream \u0026lt;git address\u0026gt;    再次通过git remote -v查看状态确认是否配置成功   同步至fork  从上游仓库fetch分支和提交点，传送至本地，并会被存储在一个本地分支upstream/master 1  git fetch upstream    切换到本地主分支 1  git checkout master    把upstream/master分支合并到本地master上，这样就完成了同步，并且不会丢掉本地修改的内容 1  git rebase upstream/master    最后一步git push origin master    强烈推荐使用rebase，因为merge之后会有记录，然后在提交PR(Pull/Request)会很难看。\n","date":"2022-06-09T00:52:08+08:00","image":"https://example.com/p/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/git_huda57afaa48c8d8e235f6c2059a3be299_35108_120x120_fill_q75_box_smart1.jpeg","permalink":"https://example.com/p/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/","title":"Git常用命令整理"},{"content":"Git的报错 在使用Git的过程中有时会出现一些问题，那么在解决了每个问题的时候，都需要去总结记录下来，下次不再犯。\n一、fatal: refusing to merge unrelated histories 今天在使用Git创建项目的时候，在两个分支合并的时候，出现了下面的这个错误。\n1  Git: fatal: refusing to merge unrelated histories   这里的问题的关键在于：fatal: refusing to merge unrelated histories 你可能会在git pull或者git push中都有可能会遇到，这是因为两个分支没有取得关系。那么怎么解决呢？\n二、解决方案 在你操作命令后面加\u0026ndash;allow-unrelated-histories 例如： git merge master \u0026ndash;allow-unrelated-histories 如果你是git pull或者git push报fatal: refusing to merge unrelated histories 同理： git pull origin master \u0026ndash;allow-unrelated-histories 等等，就是这样完美的解决咯！\n","date":"2022-06-09T00:52:08+08:00","image":"https://example.com/p/git%E7%9A%84%E6%8A%A5%E9%94%99fatal-refusing-to-merge-unrelated-histories/git_huda57afaa48c8d8e235f6c2059a3be299_35108_120x120_fill_q75_box_smart1.jpeg","permalink":"https://example.com/p/git%E7%9A%84%E6%8A%A5%E9%94%99fatal-refusing-to-merge-unrelated-histories/","title":"Git的报错:fatal: refusing to merge unrelated histories"},{"content":"Mutex ——互斥锁 解决并发问题：资源竞争，往同一个 buffer 中写入数据\n  基础用法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { var count = 0 var wg sync.WaitGroup wg.Add(10) for i := 0; i \u0026lt; 10; i++ { go func() { defer wg.Done() for j := 0; j \u0026lt; 1000; j++ { count++ } }() } wg.Wait() fmt.Println(count) } // 9288   检查并发问题： go run -race counter.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { var wg sync.WaitGroup var counter Counter wg.Add(10) for i := 0; i \u0026lt; 10; i++ { go func() { defer wg.Done() for j := 0; j \u0026lt; 100000; j++ { counter.Incr() } }() } wg.Wait() fmt.Println(counter.Count()) } type Counter struct { mux sync.Mutex count uint64 } func (c *Counter) Incr() { c.mux.Lock() c.count++ c.mux.Unlock() } func (c *Counter) Count() uint64{ c.mux.Lock() defer c.mux.Unlock() return c.count }     实现原理\nCSA:CAS 指令将给定的值和一个内存地址中的值进行比较，如果它们是同一个值，就使用新值替换内存地址中的值，这个操作是原子性的。\n  V1 \u0026ndash; flag +当前持有和等待获取锁的 goroutine 的数量 缺点：任意的 goroutine 都可以释放\n要求编码人员，编码的时候注意成对使用unlock()，一定要遵循“谁申请，谁释放”的原则。\n  V2 \u0026ndash; 优先交给正在占用 CPU 时间片的 goroutine\nmutex lock源码：\n 1-4 行 如果正好有锁 new 代表现在等待者数量 14-17 如果被信号量唤醒了，清除唤醒标志 19-20 设置状态，如果能成功地通过 CAS 把这个新值赋予state就代表抢夺锁的操作成功了。 23 等待信号量  mutex unlock源码：\n  V3 \u0026ndash; 新来的 goroutine 或者是被唤醒的 goroutine 首次获取不到锁，它们就会通过自旋\n  v4 \u0026ndash; 解决饥饿\n有的goroutine 一直等待，等不到锁，不公平。饥饿模式的最大等待时间阈值设置成了 1 毫秒，超过这个等待时间，优先获取锁\n    易错场景\n  Lock/Unlock不是成对出现\n  Copy已使用的Mutex\n12 行传入了foo()复制了一个锁\n使用 go vet main.go\n  重入 拥有锁的线程再次请求这个锁（递归锁）\n  死锁\n    知名项目中的 Bug\n docker issue36114 重入死锁 docker issue 34881 if之后直接返回 没有unlock Kubernetes issue 72361 data race 资源竞争 Kubernetes issue 45192 没有unlock etcd issue 10419 锁重入    拓展功能\n  TryLock\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;sync/atomic\u0026#34; \u0026#34;time\u0026#34; \u0026#34;unsafe\u0026#34; ) const ( mutexLocked = 1 \u0026lt;\u0026lt; iota // 加锁标示位置 \tmutexWoken // 唤醒标示位置 \tmutexStarving // 锁饥饿标示 \tmutexWaiterShift = iota // 标示Waiter的起始bit位置 ) type Mutex struct { sync.Mutex } // 尝试获取锁 func (m *Mutex) TryLock() bool { // fast path 如果一开始就没有其他g争夺，那么直接获取锁 \tif atomic.CompareAndSwapInt32((*int32)(unsafe.Pointer(\u0026amp;m.Mutex)), 0, mutexLocked) { return true } // 如果处于唤醒，加锁或者饥饿状态，这次请求就不参与了竞争了，直接返回false \told := atomic.LoadInt32((*int32)(unsafe.Pointer(\u0026amp;m.Mutex))) if old\u0026amp;(mutexLocked|mutexWoken|mutexStarving) != 0 { return false } // 尝试在竞争的状态下请求锁 \tn := old | mutexLocked return atomic.CompareAndSwapInt32((*int32)(unsafe.Pointer(\u0026amp;m.Mutex)), old, n) } func main() { var mu Mutex go func() { // 启动一个g持有一段时间的锁  mu.Lock() time.Sleep(time.Duration(rand.Intn(2)) * time.Second) mu.Unlock() }() time.Sleep(time.Second) ok := mu.TryLock() // 尝试获取锁 \tif ok { // 获取锁成功  fmt.Println(\u0026#34;got the lock\u0026#34;) // 开始你的业务  mu.Unlock() return } // 没有获取到 \tfmt.Println(\u0026#34;can\u0026#39;t get the lock\u0026#34;) }     获取等待的goroutine的信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;sync/atomic\u0026#34; \u0026#34;time\u0026#34; \u0026#34;unsafe\u0026#34; ) const ( mutexLocked = 1 \u0026lt;\u0026lt; iota // 加锁标示位置 \tmutexWoken // 唤醒标示位置 \tmutexStarving // 锁饥饿标示 \tmutexWaiterShift = iota // 标示Waiter的起始bit位置 ) type Mutex struct { sync.Mutex } func main() { var mu Mutex for i := 0; i \u0026lt; 1000; i++ { go func() { mu.Lock() time.Sleep(time.Second) mu.Unlock() }() } time.Sleep(time.Second) fmt.Printf(\u0026#34;waitings:%d,isLocked:%t,woken:%t,starving:%t\\n\u0026#34;, mu.Count(), mu.IsLocked(), mu.IsWoken(), mu.IsStarving()) } func (m *Mutex) Count() int { // 获取state字段的值 \tv := atomic.LoadInt32((*int32)(unsafe.Pointer(\u0026amp;m.Mutex))) v = v \u0026gt;\u0026gt; mutexWaiterShift // 得到等待者的数 \tv = v + (v \u0026amp; mutexLocked) // 再加上锁持有者的数量 0或者1 \treturn int(v) } // 锁是否被持有 func (m *Mutex) IsLocked() bool { state := atomic.LoadInt32((*int32)(unsafe.Pointer(\u0026amp;m.Mutex))) return state\u0026amp;mutexLocked == mutexLocked } // 是否有等待者被唤醒 func (m *Mutex) IsWoken() bool { state := atomic.LoadInt32((*int32)(unsafe.Pointer(\u0026amp;m.Mutex))) return state\u0026amp;mutexWoken == mutexWoken } // 锁是否处于饥饿状态 func (m *Mutex) IsStarving() bool { state := atomic.LoadInt32((*int32)(unsafe.Pointer(\u0026amp;m.Mutex))) return state\u0026amp;mutexStarving == mutexStarving }     线程安全的queue(Enqueue/Dequeue使用mutex)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) type SliceQueue struct { data []interface{} mu sync.Mutex } func NewQueue(n int) *SliceQueue { return \u0026amp;SliceQueue{ data: make([]interface{}, 0, n), } } // 入队 把值放在队尾 func (q *SliceQueue) Enqueue(v interface{}) { q.mu.Lock() q.data = append(q.data, v) q.mu.Unlock() } // 出队，移除队头并返回 func (q *SliceQueue) Dequeue() interface{} { q.mu.Lock() // 如果队列为空，直接返回nil \tif len(q.data) == 0 { q.mu.Unlock() return \u0026#34;队列没有数据了\u0026#34; } v := q.data[0] // 移除队头 \tq.data = q.data[1:] q.mu.Unlock() return v } func main() { var wg sync.WaitGroup queue := NewQueue(100) wg.Add(2) go func() { wg.Done() for i := 0; i \u0026lt; 100; i++ { queue.Enqueue(i) } }() go func() { for { v := queue.Dequeue() fmt.Println(\u0026#34;出队的值是：\u0026#34;, v) time.Sleep(50 * time.Millisecond) } }() wg.Wait() }     ","date":"2022-06-08T13:32:01+08:00","image":"https://example.com/p/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-mutex/5e996d4855dad999_hu8cc3d46cae446b5f5c3efe17a8070a41_71705_120x120_fill_q75_box_smart1.jpeg","permalink":"https://example.com/p/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-mutex/","title":"Go并发编程--Mutex"},{"content":"stack 主题 https://docs.stack.jimmycai.com/zh/getting-started hugo new /post/hugo文章创建.md\n","date":"2022-06-08T12:07:17+08:00","image":"https://example.com/p/hugo%E6%96%87%E7%AB%A0%E5%88%9B%E5%BB%BA/luca-bravo-alS7ewQ41M8-unsplash_hu0a3f1163de68d0b9471979ebf0ecf11e_32400_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/p/hugo%E6%96%87%E7%AB%A0%E5%88%9B%E5%BB%BA/","title":"Hugo文章创建"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用  思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n 图片 1 2 3  ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg)   相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://example.com/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.— Rob Pike1 Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Italics Bold Code     italics bold code       A B C D E F     Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien    Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10  \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10  \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   Diff code block 1 2 3 4 5  [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;]   List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Fruit  Apple Orange Banana   Dairy  Milk Cheese    Other Elements — abbr, sub, sup, kbd, mark GIFis a bitmap image format.\nH2O\nXn+ Yn= ZnPress CTRL+ALT+Deleteto end the session.\nMost salamandersare nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image \n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","date":"2019-03-11T00:00:00Z","image":"https://example.com/p/markdown%E8%AF%AD%E6%B3%95%E6%8C%87%E5%AF%BC/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/p/markdown%E8%AF%AD%E6%B3%95%E6%8C%87%E5%AF%BC/","title":"Markdown语法指导"}]